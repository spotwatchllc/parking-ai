/**
  ******************************************************************************
  * @file    ai_dpu.c
  * @author  MCD Application Team
  * @version V1.0.0
  * @date    25-November-2024
  * @brief   This file is implementing ai processing functions that are making
  * 		 use of libraries generated by X-CUBE-AI
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "logging.h"

/* Standard includes. */
#include <string.h>
#include <stdio.h>

/* Kernel includes. */
#include "ai_dpu.h"


/* Private function prototypes -----------------------------------------------*/
static void extract_ll_buffer_shape(const LL_Buffer_InfoTypeDef *p_aton_buf,\
                                    struct _shape_desc *p_shape)
{
  p_shape->ndims = p_aton_buf->ndims;
  if ((p_aton_buf->batch > 1) || (p_aton_buf->ndims < 4)) {
    for (int i=0; i< p_aton_buf->ndims; i++)
      p_shape->shape[i] = p_aton_buf->shape[i];
  }
  else {
    p_shape->shape[0] = p_aton_buf->shape[0];
    p_shape->shape[1] = p_aton_buf->shape[3];
    p_shape->shape[2] = p_aton_buf->shape[1];
    p_shape->shape[3] = p_aton_buf->shape[2];
  }
}

static int AiDPUCheckModel(AIProcCtx_t * pxCtx)
{
  struct npu_model_info *info ;
  int res = 1;
  const LL_Buffer_InfoTypeDef* p_buffer;
  assert_param(pxCtx != NULL);
  struct _shape_desc shape;
 
  info = &pxCtx->net_exec_ctx->info;
 
  if (info->n_inputs > AI_DPU_NB_MAX_INPUT )
  {
    res = 0;
  }
  if (info->n_inputs > AI_DPU_NB_MAX_OUTPUT )
  {
    res = 0;
  }

  for (int i=0; i< info->n_inputs ; i++ )
  {
    p_buffer = info->in_bufs[i];
    extract_ll_buffer_shape(p_buffer, &shape);
    if (p_buffer->type !=  DataType_INT8         ||
        shape.ndims !=  4                        ||
        shape.shape[0] > AI_DPU_SHAPE_BATCH_MAX  ||
        shape.shape[1] > AI_DPU_SHAPE_HEIGHT_MAX ||
        shape.shape[2] > AI_DPU_SHAPE_WIDTH_MAX  ||
        shape.shape[3] > AI_DPU_SHAPE_CHANNEL_MAX )
    {
      res = 0;
    }
  }
  for (int i=0; i< info->n_outputs ; i++ )
  {
    p_buffer = info->out_bufs[i];
    extract_ll_buffer_shape(p_buffer, &shape);
    if (p_buffer->type !=  DataType_FLOAT         ||
        shape.ndims !=  4                         ||
        shape.shape[0] > AI_DPU_SHAPE_BATCH_MAX   ||
        shape.shape[1] > AI_DPU_SHAPE_HEIGHT_MAX  ||
        shape.shape[2] > AI_DPU_SHAPE_WIDTH_MAX   ||
        shape.shape[3] > AI_DPU_SHAPE_CHANNEL_MAX )
    {
      res = 0;
    }
  }

  if (res == 0)
  {
     LogWarn("AI_DPU: Model check failed \r\n");
  }

  return res;
}

static void print_ll_io_buffer(const LL_Buffer_InfoTypeDef *aton_buf)
{
  struct _shape_desc shape;
  
  extract_ll_buffer_shape(aton_buf, &shape);

  LogInfo(" name    : %s\r\n", aton_buf->name);
  LogInfo("  addr   : 0x%x (%d bytes)  (%d bits)\r\n",
           (uint32_t)LL_Buffer_addr_start(aton_buf),
           get_ll_buffer_size(aton_buf),
           aton_buf->nbits);
  LogInfo("  type   : %d shape(%d)=(", aton_buf->type, shape.ndims);
  
  for (int i=0; i<shape.ndims; i++)
    if (i == shape.ndims - 1)
      LogInfo("%d", shape.shape[i]);
    else
      LogInfo("%d,", shape.shape[i]);
  LogInfo(")\r\n");
  
  if (aton_buf->scale) {
    LogInfo("  quant  : scale=%f, zp=%d\r\n", aton_buf->scale[0],
             aton_buf->offset[0]);
  }
}

/* External functions --------------------------------------------------------*/
int  AiDPULoadModel(AIProcCtx_t * pxCtx, const char *name)
{
  struct npu_model_info *info ;
  assert_param(pxCtx != NULL);
  
  npu_get_instance_by_index(0, pxCtx->net_exec_ctx);
  npu_init(pxCtx->net_exec_ctx, 1);

  info = &pxCtx->net_exec_ctx->info;
  if ( info->in_bufs[0]->scale[0] != 0 )
  {
    pxCtx->input_Q_inv_scale = 1.0F/info->in_bufs[0]->scale[0];
  }
  else
  {
    LogError("Scale factor muist not be null\r\n");
  }
  pxCtx->input_Q_offset    = info->in_bufs[0]->offset[0];
  
  LogInfo("\r\n");
  LogInfo("ATONN Model\r\n");
  LogInfo("--------------------------------------------------\r\n");
  LogInfo(" name          : %s\r\n", info->name);
  LogInfo(" n_epochs      : %d\r\n", info->n_epochs);
  LogInfo(" params        : %d KiB\r\n", (int)(info->params / 1024));
  LogInfo(" activations   : %d KiB\r\n", (int)(info->activations / 1024));

  LogInfo(" n_inputs      : %d\r\n", info->n_inputs);
  for (int idx=0; idx < info->n_inputs; idx++) {
    print_ll_io_buffer(info->in_bufs[idx]);
  }
  
  LogInfo(" n_outputs     : %d\r\n", info->n_outputs);
  for (int idx=0; idx < info->n_outputs; idx++) {
    print_ll_io_buffer(info->out_bufs[idx]);
  }
  return AiDPUCheckModel(pxCtx);
}

int AiDPUReleaseModel(AIProcCtx_t * pxCtx)
{
  return 1;
}

int AiDPUProcess(AIProcCtx_t *pxCtx)
{
  assert_param(pxCtx != NULL);
  uint32_t inf_time_ms = npu_run(pxCtx->net_exec_ctx, NULL);
  LogDebug("AI inference %d us \r\n",inf_time_ms*1000 );        
  return 1;
}
